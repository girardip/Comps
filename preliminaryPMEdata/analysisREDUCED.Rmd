---
title: "reducedPMEprototypeAnalysis"
author: "Pedro Girardi"
date: "December 11, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## PME 


```{r}
library(tidyverse)
library(readr)
library(readxl)
library(dicionariosIBGE)
```

```{r Importing Data}
setwd("~/Comps/preliminaryPMEdata/")
reduced_pme = read.csv("pme_reduced.csv")[,-1]
reduced_pme_original = reduced_pme
colnames(reduced_pme_original) = sub('.*\\.', '', colnames(reduced_pme_original))
```

```{r Relabeling Columns}
# PME relabeling (depends on what variables I imported)
names(reduced_pme) = c("Gender", "Month", "Household", "MetropolitanArea", "Income")
# find a way to also relabel the categories themselves
```

```{r Manipulating Income Variable}
# manipulation of income variable
mean(is.na(reduced_pme$Income))
mean(reduced_pme$Income==0, na.rm=T) 
#there are people with income of 0. I will add $1 to all incomes so we don't have issues with log
# only getting the observations with income
percentiles_income = quantile(reduced_pme$Income, probs = 1:100/100, na.rm=T)# some percentiles are off at the very top (people making 10^9 reals)
reduced_pme = reduced_pme %>% filter(Income<1e6)
reduced_pme = reduced_pme[complete.cases(reduced_pme),]
reduced_pme$logIncome = log(reduced_pme$Income+1)
reduced_pme$MetropolitanArea = as.factor(reduced_pme$MetropolitanArea)
# summary(reduced_pme)
# hist(reduced_pme$logIncome) # I should probably remove the 0s and they will be overly influential 
reduced_pme = reduced_pme %>% filter(Income>0)
```

```{r Relabeling Factors}
dictionaryPME = read_xls("~/Comps/PME/documentacao/Layout/dicionario.xls", skip = 7, col_names = F)
names(dictionaryPME) = c("inicio", "tamanho", "cod", "desc", "valor", "rotulo")
# fixing NAs 
for (i in 1:(length(dictionaryPME$cod)-1)){
  if (is.na(dictionaryPME$cod[i+1])) {
    dictionaryPME$cod[i+1] = dictionaryPME$cod[i]
  }
}
dictionaryPME = dictionaryPME %>%
  group_by(cod) %>%
  mutate(inicio = max(inicio, na.rm = T))

# relabeling and re-organizing so I can use the dicionariosIBGE package
rotPME = dictionaryPME[,c(3,5,6)]
dictionaryPME = dictionaryPME[,c(1,3,2,4)]
dictionaryPME = dictionaryPME[complete.cases(dictionaryPME),]

# relabeling factor variables
rotPME = rotPME[!is.na(rotPME$valor),] #taking NAs out
rotPME = rotPME[rotPME$valor>=0&rotPME$valor<=99,] # keeping only factor variables
originalColNames = str_to_upper(colnames(reduced_pme_original))
rotPME = rotPME %>% filter(cod %in% originalColNames)
# for (i in 1:length(reduced_pme_original[,-5])){
#   currentRotPME = rotPME %>% filter(cod==originalColNames[i])
#   currentPMEindicator = reduced_pme_original[,i]
#   for (j in 1:length(currentPMEindicator)){
#     for (k in 1:nrow(currentRotPME)){
#       if (currentPMEindicator[j]==currentRotPME$cod[k]) {
#         currentPMEindicator[j] = currentRotPME$rotulo[k]
#       }
#     }
#   }
# }

# relabeling current PME dataset (colnames only)
for (j in 1:length(originalColNames)){
  for (i in 1:nrow(dictionaryPME)){
    if (originalColNames[j] == dictionaryPME$cod[i]) {
      originalColNames[j] = dictionaryPME$desc[i]
    }
  }
}
originalColNames = str_replace_all(originalColNames, " ", "")



```

## Inflation


```{r Reading Inflation}
inflation = read_csv("inflationCleaned.csv")[,-1] %>% 
  filter(Region != "Brasil") %>% 
  mutate(Region = str_sub(string = Region,
                          end = -6)) #removing Brazil data and abbreviation of cities

inflation = inflation %>%
  mutate(Region = as.factor(Region))

inflation = inflation %>% 
  group_by(Region) %>% 
  mutate(PriceIndex = cumprod(1+Inflation/100)) #creates CPI


# matching inflation with cases at PME
rotPMEstates = rotPME%>% filter(cod=="V035", valor%in%levels(reduced_pme$MetropolitanArea))

reduced_pme$MetropolitanArea = plyr::mapvalues(reduced_pme$MetropolitanArea,
                                         from = levels(reduced_pme$MetropolitanArea),
                                         to = levels(as.factor(rotPMEstates$rotulo)))

# joining the datasets
complete.df = left_join(reduced_pme, inflation, by=c("MetropolitanArea" = "Region", "Month" = "Month"))
```
## Adding Growth

````{r}
growthData = read_csv(file = "growthData.csv", col_types = c("cd"))
colnames(growthData)=c("Month", "GDP_Nominal")
growthData = growthData %>% mutate(Year = as.integer(str_sub(Month, end = 4)),
                                   Month = as.integer(str_sub(Month, start = 6)))
# need to get the REAL GDP, not Nominal
inflationBR = read_csv("inflationCleaned.csv")[,-1] %>% 
  filter(Region == "Brasil")
inflationBR = inflationBR %>%
  mutate(Region = as.factor(Region))
inflationBR = inflationBR %>% 
  mutate(PriceIndex = cumprod(1+Inflation/100)) #creates CPI

growthData = growthData %>% left_join(inflationBR, by = c("Month", "Year" = "year"))
growthData = growthData[complete.cases(growthData),] 
growthData = growthData %>% mutate(RealGDP = GDP_Nominal/PriceIndex)

cleanGrowthData = growthData %>% select(Month, Year, RealGDP) %>% mutate(ChangeInGDP = RealGDP-lag(RealGDP))
# merging
complete.df = complete.df %>% left_join(cleanGrowthData)
````

Because I am looking at the power of inflation on real income, I NEED TO account for the positive impact of inflation on NOMINAL terms. So I should adjust income such that if there was no change in real terms, $Y_{t+1}=Y_t\cdot (\pi_t+1) $. If not, hyperinflation would automatically trigger a false positive relation between the variables. This will be particularly relevant when looking at the final longitudinal analysis.

````{r}
complete.df = complete.df %>% mutate(RealIncome = Income/PriceIndex,
                                     logRealIncome = log(RealIncome))
````


````{r}
# selecting only people in the bottom quintile of the income distribution at any given period
# keep in mind this WONT be the final method (NOT TRACKING OVER TIME, REPEATED OBS OF INDIVIDUALS)

complete.df = complete.df %>% group_by(Month) %>% mutate(Poor = ifelse(RealIncome <= quantile(RealIncome, probs = .2), T, F))
poor.df = complete.df %>% filter(Poor==T)
````

## Running the analysis

```{r}
lm1 = lm(data=poor.df, logRealIncome ~ Gender + Month +
           MetropolitanArea + Inflation + ChangeInGDP)
lm2 = update(lm1, . ~ . + Gender*Inflation)

summary(lm1)
summary(lm2)
anova(lm1, lm2, test="Chisq")
```



